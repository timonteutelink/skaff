---
title: Using the Web Interface
---

In addition to the CLI, Code Templator provides a **Web Interface** for those who prefer a visual, interactive experience. The web UI is essentially a local web app that lets you browse templates, fill in template options via forms, and preview the changes before applying them. This section explains how to run the web interface and what you can do with it.

## Running the Web UI

The web UI is packaged as a Next.js application in the monorepo (`apps/web`). You have a couple of options to run it:

**1. Using Docker (recommended for easy start):** We provide a Docker image that contains the web app and all necessary dependencies. This is ideal if you don’t want to set up a Node environment for the UI.

* Make sure Docker is installed and running on your system.
* Pull the latest image:

  ```bash
  docker pull timonteutelink/code-templator-web:latest
  ```
* Run the container:

  ```bash
  docker run -p 3000:3000 -v ~/.config/code-templator:/home/node/.config/code-templator timonteutelink/code-templator-web:latest
  ```

  This command maps port 3000 from the container to port 3000 on your localhost, and also mounts your local Code Templator config directory into the container so it can read your `templatePaths` and other settings.
* Now open your browser to **`http://localhost:3000`**. You should see the Code Templator interface.

**2. Running locally with Node:** If you have Node.js and pnpm installed and have cloned the `code-templator` repository, you can run the web app directly:

* Install dependencies in the monorepo: `pnpm install`
* Build the core libraries: `pnpm build` (this compiles the packages so the web app can use them)
* Start the dev server: `pnpm --filter apps/web dev` (this runs the Next.js app in development mode on port 3000 by default)
* Open **`http://localhost:3000`** in your browser.

> **Note:** The web app expects access to the same template repositories as your CLI. It will read your config (in `~/.config/code-templator`) for the `templatePaths` setting. If you configured templates in the CLI, the same config should be mounted or available to the web app. If you run the app locally, it uses your home directory’s config by default. If you run via Docker, ensure you mount the config volume as shown above or use the web UI’s settings page to add template paths.

## Browsing and Selecting Templates

Once the web interface is running, you’ll typically go through these steps:

**1. Browse Templates:** The home screen of the app shows the list of available root templates (the same ones `code-templator template default` would list). For each template, you might see a name, description, and author. Click on a template to start using it.

**2. Template Details:** After selecting a template, you’ll see a page with more details:

* A longer description (if provided by the template).
* Possibly links to documentation or README of that template.
* A list of **options/fields** to fill out. These fields are generated from the template’s Zod schema. Each field will have a label and maybe a help description (for example, “Project Name”, “Author”, or feature toggles like “Include Docker?”). Required fields will be indicated, and some may have default values.

**3. Fill in Template Settings:** Enter values for the template’s settings. The web UI will validate them in real-time (e.g., if a field is supposed to be an integer or match a certain pattern, you’ll get an error hint if it doesn’t). For boolean toggles or enumerations, you might see checkboxes or dropdowns. The goal here is to configure your project exactly how you want it.

**4. Subtemplate Selection:** Some templates might have optional subtemplates that can be toggled on or off *at creation time*. For example, a “Web App” template might list options like “Include authentication module” or “Add example unit tests” – enabling these will effectively turn on certain subtemplates before the project is first generated. In the web UI, these might just be additional checkboxes or nested sections of the form.

**5. Preview Changes:** Here’s a powerful feature of the web UI – you can **preview the generated project or diff** before applying it. There’s usually a “Preview” or “Diff” button once you’ve filled the form. Clicking this will tell Code Templator to simulate the generation:

* If you are creating a new project, it will show you the full directory structure and files that will be created, often in a side-by-side diff view (where the “new” side has all the content and the “old” side is empty since it’s a new project).
* If you are adding a subtemplate to an existing project (more on that in a moment), it will show the diff of what will change in the project.

Reviewing the diff is a great way to verify the template will do what you expect. For example, you can inspect that the project name was correctly inserted in all files, or that enabling a feature adds the expected files.

**6. Apply (Generate or Patch):** When you’re happy with the configuration, hit the **“Apply”** or **“Generate Project”** button. For new projects, you’ll be prompted to choose a directory or confirm the project name/location. The web UI will then run the generation and finally give you a link or instructions to access the generated project (since the web app can’t directly open your file explorer, it might simply confirm success and you’ll see the files on disk). For applying changes to an existing project, the web UI will apply the patch to the git repo of that project – you should then see those changes in your project’s working copy.

**7. Next Steps after Generation:** After generating via the web UI, you’ll need to open a terminal if you want to run the project (the web interface doesn’t run shell commands in your project). So typically you’d `cd` into the project directory and start the dev server or open your IDE from there.

## Using the Web UI for Existing Projects

The web interface isn’t only for new projects. You can also use it to **manage an existing Code Templator-generated project**. How?

If you open the web app and navigate to the “Projects” section (if available), you might be able to point the UI to an existing project on disk that was previously generated. Alternatively, if you start the web UI from *within* a project directory (depending on how it’s built, it might auto-detect if you launched it with context), it could load that project.

Assuming the project is loaded in the UI, you could then:

* View the project’s current template state (which root template and subtemplates are present).
* Add a new subtemplate: e.g., select the parent (or root) in some UI and choose an available subtemplate to apply. This triggers the same diff-preview-apply cycle, but now targeting that project.
* Remove or modify subtemplates: The UI might list subtemplates currently applied and give you options to remove them or change settings (if the template supports modifying settings via a diff).
* Update the project’s template version: If a newer version of the template is available, the UI could present an “Update Project” button. Clicking it would fetch the latest template and show you the diff of changes (just like the CLI `prepare-update` command). You can then apply the update patch from the UI.

All of these are designed to be user-friendly alternatives to running CLI commands. Behind the scenes, the same git diff and patch mechanism is used, so you’re not losing any safety by using the UI.

## Web UI Tech Stack (for Contributors)

If you’re interested in how the web app is built (especially if you want to contribute to it), here’s a brief overview:

* It’s a Next.js 13 app using the App Router (React 18). Pages are mostly server-side rendered or use React Server Components where appropriate for data fetching.
* Styling is done with Tailwind CSS, and it leverages the ShadCN/UI library (a collection of accessible React components built on Radix UI and styled with Tailwind). This gives it a modern look and feel with minimal custom CSS.
* It uses **tRPC** with Zod for the API layer. This provides end-to-end type safety – the web app can call backend functions (like “load templates”, “generate diff”) with full type checking, and these backend routes in turn call the Code Templator core library functions.
* Authentication (if any) isn’t heavily used for local, but NextAuth is set up for GitHub or email login. This might be more relevant if you run a persistent instance.
* The file structure of the app is modular; for example, there’s a `(dashboard)` segment for protected routes (if you log in), and components split by features (you can see a snippet of the folder structure in the docs).
* We have tests using Playwright and Jest to ensure the UI works and to catch regressions.

For more details on contributing to the web app, see the **Contributing** section. And if you want to hack on the UI, it’s as simple as running it in dev mode and editing the React components – hot reload will update the interface.

---

Next up: now that you’re comfortable using Code Templator, learn how to create your own templates in our **Template Authoring Guide**.
