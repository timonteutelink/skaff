import {
  AutoInstantiatedSubtemplate,
  FinalTemplateSettings,
  UserTemplateSettings,
} from "@timonteutelink/template-types-lib";
import { backendLogger } from "../../../lib/logger";
import { Result } from "../../../lib/types";
import { anyOrCallbackToAny, cloneValue } from "../../../lib/utils";
import { GeneratorOptions } from "../template-generator-service";
import { ProjectSettingsSynchronizer } from "../ProjectSettingsSynchronizer";
import { TemplatePipelineContext } from "./TemplatePipelineContext";

/**
 * Plans and executes automatic subtemplate instantiation during pipeline runs.
 *
 * Templates can declare child templates that should be instantiated whenever a
 * parent is rendered. This coordinator resolves those declarations, registers
 * new template instances in project settings, and invokes the template
 * instantiation pipeline recursively while keeping the parent context intact.
 */
export class AutoInstantiationCoordinator {
  constructor(
    private readonly options: GeneratorOptions,
    private readonly context: TemplatePipelineContext,
    private readonly projectSettingsSynchronizer: ProjectSettingsSynchronizer,
    private readonly instantiateTemplate: (
      templateInstanceId: string,
      options?: { removeOnFailure?: boolean },
    ) => Promise<Result<{
      targetPath: string;
      finalSettings: FinalTemplateSettings;
    }>>,
  ) { }

  public getTemplatesToAutoInstantiateForCurrentTemplate(): Result<
    AutoInstantiatedSubtemplate[]
  > {
    const stateResult = this.context.getState();

    if ("error" in stateResult) {
      return stateResult;
    }

    const templatesToAutoInstantiate = anyOrCallbackToAny(
      stateResult.data.template.config.autoInstantiatedSubtemplates,
      stateResult.data.finalSettings,
    );

    if ("error" in templatesToAutoInstantiate) {
      return templatesToAutoInstantiate;
    }

    return { data: templatesToAutoInstantiate.data ?? [] };
  }

  public async autoInstantiateSubTemplates(
    fullParentSettings: FinalTemplateSettings,
    parentTemplateInstanceId: string,
    templatesToAutoInstantiate?: AutoInstantiatedSubtemplate[],
  ): Promise<Result<void>> {
    if (this.options.dontAutoInstantiate) {
      return { data: undefined };
    }

    const parentStateResult = this.context.getState();

    if ("error" in parentStateResult) {
      return parentStateResult;
    }

    const parentState = parentStateResult.data;

    for (const templateToAutoInstantiate of templatesToAutoInstantiate || []) {
      const autoGeneratedTemplateUserSettings = anyOrCallbackToAny(
        templateToAutoInstantiate.mapSettings,
        cloneValue(fullParentSettings),
      );

      if ("error" in autoGeneratedTemplateUserSettings) {
        return autoGeneratedTemplateUserSettings;
      }

      const childUserSettings =
        autoGeneratedTemplateUserSettings.data as UserTemplateSettings;

      const nameOfTemplateToAutoInstantiate =
        templateToAutoInstantiate.subTemplateName;

      const templateToInstantiate = parentState.template.findSubTemplate(
        nameOfTemplateToAutoInstantiate,
      );

      if (!templateToInstantiate) {
        backendLogger.error(
          `Template ${nameOfTemplateToAutoInstantiate} not found in ${parentState.template.config.templateConfig.name}`,
        );
        return {
          error: `Template ${nameOfTemplateToAutoInstantiate} not found in ${parentState.template.config.templateConfig.name}`,
        };
      }

      if (
        !templateToInstantiate.parentTemplate ||
        templateToInstantiate.parentTemplate.config.templateConfig.name !==
        parentState.template.config.templateConfig.name
      ) {
        backendLogger.error(
          `Subtemplate ${templateToAutoInstantiate.subTemplateName} is not a child of template ${parentState.template.config.templateConfig.name}`,
        );
        return {
          error: `Subtemplate ${templateToAutoInstantiate.subTemplateName} is not a child of template ${parentState.template.config.templateConfig.name}`,
        };
      }

      const childFinalTemplateSettingsResult =
        this.projectSettingsSynchronizer.getFinalTemplateSettings(
          templateToInstantiate,
          childUserSettings,
          parentTemplateInstanceId,
        );

      if ("error" in childFinalTemplateSettingsResult) {
        return childFinalTemplateSettingsResult;
      }

      let childFinalTemplateSettings =
        childFinalTemplateSettingsResult.data;

      const addTemplateResult = this.projectSettingsSynchronizer.addNewTemplate(
        cloneValue(childUserSettings),
        nameOfTemplateToAutoInstantiate,
        parentTemplateInstanceId,
        true,
      );

      if ("error" in addTemplateResult) {
        return addTemplateResult;
      }

      const instantiatedTemplateId = addTemplateResult.data;

      const instantiateTemplateResult = await this.instantiateTemplate(
        instantiatedTemplateId,
        { removeOnFailure: true },
      );

      if ("error" in instantiateTemplateResult) {
        this.context.setCurrentState(parentState);
        return instantiateTemplateResult;
      }

      childFinalTemplateSettings =
        instantiateTemplateResult.data.finalSettings;

      const childrenTemplatesToAutoInstantiate =
        templateToAutoInstantiate.children;

      if (childrenTemplatesToAutoInstantiate) {
        this.context.setCurrentState({
          template: templateToInstantiate,
          finalSettings: childFinalTemplateSettings,
          parentInstanceId: instantiatedTemplateId,
        });

        const autoInstantiationResult = await this.autoInstantiateSubTemplates(
          cloneValue(childFinalTemplateSettings),
          instantiatedTemplateId,
          childrenTemplatesToAutoInstantiate,
        );

        if ("error" in autoInstantiationResult) {
          this.context.setCurrentState(parentState);
          return autoInstantiationResult;
        }
      }

      this.context.setCurrentState(parentState);
    }

    return { data: undefined };
  }
}
